# [Erlang/OTP](https://www.erlang.org)

**Erlang** это язык программирования и среда выполнения для создания масштабируемых систем реального времени с требованиями к высокой доступности.

**OTP** это набор библиотек Erlang, который состоит из среды выполнения Erlang, ряда готовых к использованию компонентов, написанных в основном на языке Erlang, и набора принципов проектирования программ Erlang ([Узанть больше](http://erlang.org/doc/system_architecture_intro/sys_arch_intro.html)). [Релизы](http://erlang.org/download/otp_versions_tree.html) для всех версий OTP.

# Установка Erlang

### Windows

Система поставляется в виде исполняемого файла установщика Windows. Получить его можно на http://www.erlang.org/download.html

Чтобы подтвердить установку запустите Erlang/OTP, дважды щелкнув значок быстрого доступа Erlang на рабочем столе.

Ожидайте, что появится окно командной строки с выводом, выглядящим примерно так:

``` Erlang
Erlang/OTP 17 [erts-6.0] [64-bit] [smp:2:2]

Eshell V6.0  (abort with ^G)
1>
```

Чтобы выйти, введите команду halt().

```
2> halt().
```

Это закрывоет оболочку Erlang/OTP.

# Установка OTP

Пожалуйста воспользуйтесь актуальной версией интсрукции под вашу платформу с официального репозитория.

* [Win32](http://erlang.org/documentation/doc-10.3/doc/installation_guide/INSTALL-WIN32.html)
* [Cross](http://erlang.org/documentation/doc-10.3/doc/installation_guide/INSTALL-CROSS.html)
* [Общий список](https://github.com/erlang/otp/tree/master/HOWTO)

# Getting Started

## 1. Последовательное программирование
## 1.1. Оболочка
Большинство операционных систем имеют интерпретатор команд или оболочку, UNIX и Linux имеют много, Windows имеет командную строку. Erlang имеет свою собственную оболочку, в которой биты кода Erlang могут быть записаны непосредственно и оценены, чтобы увидеть, что происходит.

Запустите оболочку Erlang (в Linux или UNIX), запустив оболочку или интерпретатор команд в вашей операционной системе и набрав erl. Вы увидите нечто подобное.

```
% erl
Erlang R15B (erts-5.9.1) [source] [smp:8:8] [rq:8] [async-threads:0] [hipe] [kernel-poll:false]

Eshell V5.9.1  (abort with ^G)
1>
```

Введите "2 + 5." в оболочке, а затем нажмите Enter (возврат каретки). Обратите внимание, что вы сообщаете оболочке, что закончили вводить код, закончив с полной остановкой "." и Enter.

```
1> 2 + 5.
7
2>
```

Нажмите Control-C, чтобы выключить систему Erlang и оболочку Erlang.

## 1.2. Модули и функции

Язык программирования не очень полезен, если вы можете запускать код только из оболочки. Итак, вот небольшая программа Эрланга. Введите его в файл с именем tut.erl с помощью подходящего текстового редактора. Имя файла tut.erl важен, а также то, что он находится в том же каталоге, что и тот, с которого вы начали erl). Вот код для ввода:

```
-module(tut).
-export([double/1]).

double(X) ->
    2 * X.
```

В оболочке:

```
3> c(tut).
{ok,tut}
```

Теперь запустите программу:

```
4> tut:double(10).
20
```

Вернемся к коду. Первая строка кода в модуле - это имя модуля.

```
-module(tut).
```

Таким образом, модуль называется tut. Обратите внимание на полную остановку "." в самом конце строки. Файлы, используемые для хранения модуля, должны иметь то же имя, что и сам модуль, но с расширением ".erl". В этом случае имя файла-tut.erl. При использовании функции в другом модуле используется синтаксис module_name:function_name(аргументы). Таким образом, следующее означает вызов функции double в модуле tut с аргументом "10".

```
4> tut:double(10).
```

Во второй строке говорится, что модуль tutor содержит функцию double, которая принимает один аргумент (X в нашем примере):

```
-export([double/1]).
```

Во второй строке также говорится, что эта функция может быть вызвана из-за пределов модуля tut. Подробнее об этом чуть позже. Опять же, обратите внимание на "." в самом конце строки.

У Erlang есть много стандартных модулей, которые помогут вам сделать что-то. Например, модуль ввода-вывода содержит множество функций, которые помогают выполнять форматированный ввод-вывод. Для поиска информации о стандартных модулях можно использовать команду erl-man в операционной оболочке или командной строке (там же, где вы запустили erl). Попробуйте выполнить команду оболочки операционной системы:

```
% erl -man io
ERLANG MODULE DEFINITION                                    io(3)

MODULE
     io - Standard I/O Server Interface Functions

DESCRIPTION
     This module provides an  interface  to  standard  Erlang  IO
     servers. The output functions all return ok if they are suc-
     ...
```

## 1.3. Вывод в терминал

Приятно иметь возможность делать форматированный вывод в примерах, поэтому в следующем примере показан простой способ использования функции io:format. Как и все другие экспортируемые функции, вы можете протестировать функцию io:format в оболочке:

```
31> io:format("hello world~n", []).
hello world
ok
32> io:format("this outputs one Erlang term: ~w~n", [hello]).
this outputs one Erlang term: hello
ok
33> io:format("this outputs two Erlang terms: ~w~w~n", [hello, world]).
this outputs two Erlang terms: helloworld
ok
34> io:format("this outputs two Erlang terms: ~w ~w~n", [hello, world]).
this outputs two Erlang terms: hello world
ok
```

# 2. Типы

## 2.1. Атомы

Atom-это еще один тип данных в Erlang. Атомы начинаются с маленькой буквы (см. Атом), например, ``` charles ``` и ``` centimeter```. Атомы - это просто имена, и ничего больше. Они не похожи на переменные, которые могут иметь значение.

Введите следующую программу в файл с именем tut2.erl). Это может быть полезно для преобразования из дюймов в сантиметры и наоборот:

```
-module(tut2).
-export([convert/2]).

convert(M, inch) ->
    M / 2.54;

convert(N, centimeter) ->
    N * 2.54.
```
```
9> c(tut2).
{ok,tut2}
```
```
10> tut2:convert(3, inch).
1.1811023622047243
11> tut2:convert(7, centimeter).
17.78
```

## 2.2. Кортежи

Рассмотрим:

```
tut2:convert(3, inch).
```

Означает ли это, что 3 это дюймы? Или это означает, что 3 это сантиметры и должно быть преобразовано в дюймы? У Эрланга есть способ сгруппировать вещи вместе, чтобы сделать их более понятными. Они называются кортежами и окружены фигурными скобками "{" и "}".

Так, {дюйма,3} обозначает 3 дюйма и {сантиметр,5} обозначает 5 сантиметров. Теперь давайте напишем новую программу, которая преобразует сантиметры в дюймы и наоборот. Введите следующий код в файл под названием tut3.erl):

```
-module(tut3).
-export([convert_length/1]).

convert_length({centimeter, X}) ->
    {inch, X / 2.54};
convert_length({inch, Y}) ->
    {centimeter, Y * 2.54}.
```

```
14> c(tut3).
{ok,tut3}
15> tut3:convert_length({inch, 5}).
{centimeter,12.7}
16> tut3:convert_length(tut3:convert_length({inch, 5})).
{inch,5.0}
```

Кортежи могут иметь более двух частей, фактически столько частей, сколько вы хотите, и содержать любой допустимый термин Erlang. Например, для представления температуры различных городов мира:

```
{moscow, {c, -10}}
{cape_town, {f, 70}}
{paris, {f, 28}}
```

Кортежи имеют фиксированное количество элементов в них. Каждый элемент в кортеже называется элементом. В кортеже {Москва,{c,-10}} элемент 1 является Москвой, а элемент 2 - {c, -10}. Здесь 'c' обозначает Цельсий, а f-Фаренгейт.

## 2.3. Списки

В то время как кортежи группируют вещи вместе, также необходим тип для представления списков вещей. Списки в Erlang заключены в квадратные скобки, "["и "]". Например, список температур различных городов мира может быть таким:

```
[{moscow, {c, -10}}, {cape_town, {f, 70}}, {stockholm, {c, -4}},
 {paris, {f, 28}}, {london, {f, 36}}]
```

Обратите внимание, что этот список был настолько длинным, что не помещался в одной строке. Это не имеет значения, Эрланг допускает разрывы линий во всех "чувствительных местах", но не, например, в середине атомов, целых чисел и других.

Полезным способом просмотра частей списков является использование "|". Это лучше всего объяснить на примере использования оболочки:

```
17> [First |TheRest] = [1,2,3,4,5].
[1,2,3,4,5]
18> First.
1
19> TheRest.
[2,3,4,5]
```

```
20> [E1, E2 | R] = [1,2,3,4,5,6,7].
[1,2,3,4,5,6,7]
21> E1.
1
22> E2.
2
23> R.
[3,4,5,6,7]
```

```
24> [A, B | C] = [1, 2].
[1,2]
25> A.
1
26> B.
2
27> C.
[]
```

В следующем примере показано, как найти длину списка. Введите следующий код в файл с именем tut4.erl):

```
-module(tut4).

-export([list_length/1]).

list_length([]) ->
    0;    
list_length([First | Rest]) ->
    1 + list_length(Rest).
```
```
28> c(tut4).
{ok,tut4}
29> tut4:list_length([1,2,3,4,5,6,7]).
7
```

<strong> Erlang не имеет строкового типа данных. Вместо этого строки могут быть представлены списками символов Юникода. Это означает, например, что список [97,98,99] эквивалентен "abc". Оболочка Erlang является "умной" и угадывает, какой список вы имеете в виду, и выводит его в том виде, который он считает наиболее подходящим, например: </strong>

```
30> [97,98,99].
"abc"
```

# 3. Пример

```
%% This module is in file tut5.erl

-module(tut5).
-export([format_temps/1]).

%% Only this function is exported
format_temps([])->                        % No output for an empty list
    ok;
format_temps([City | Rest]) ->
    print_temp(convert_to_celsius(City)),
    format_temps(Rest).

convert_to_celsius({Name, {c, Temp}}) ->  % No conversion needed
    {Name, {c, Temp}};
convert_to_celsius({Name, {f, Temp}}) ->  % Do the conversion
    {Name, {c, (Temp - 32) * 5 / 9}}.

print_temp({Name, {c, Temp}}) ->
    io:format("~-15w ~w c~n", [Name, Temp]).
```

```
35> c(tut5).
{ok,tut5}
36> tut5:format_temps([{moscow, {c, -10}}, {cape_town, {f, 70}},
{stockholm, {c, -4}}, {paris, {f, 28}}, {london, {f, 36}}]).
moscow          -10 c
cape_town       21.11111111111111 c
stockholm       -4 c
paris           -2.2222222222222223 c
london          2.2222222222222223 c
ok
```

Прежде чем посмотреть, как работает эта программа, обратите внимание, что к коду добавляется несколько комментариев. Комментарий начинается с символа ```%``` и продолжается до конца строки. Обратите также внимание, что ```-export ([format_temps/1])```. строка содержит только функцию ```format_temps/1```. Остальные функции являются локальными функциями, то есть они не видны снаружи модуля ```tut5```.

Обратите также внимание, что при тестировании программы из оболочки входные данные распределяются по двум строкам, так как линия была слишком длинной.

Когда ```format_temps``` вызывается в первый раз, ```City``` получает значение ```{moscow, {c, -10}}```, а ```Rest``` - это остальная часть списка. Поэтому вызывается функция ```print_temp (convert_to_celsius({moscow, {c, -10}}))```.

Вот вызов функции как ```convert_to_celsius({moscow, {c, -10}})``` в качестве аргумента функции ```print_temp```. Когда вызовы функций вложены подобным образом, они выполняются (вычисляются) изнутри наружу. То есть сначала вычисляется ```convert_to_celsius({moscow,{c,-10}})```, который дает значение ```{moscow,{c,-10}}```, так как температура уже находится в градусах Цельсия. Затем вычисляется ```print_temp({moscow, {c, -10}})```. Функция ```convert_to_celsius``` работает аналогично функции ```convert_length``` в предыдущем примере.

```print_temp``` просто вызывает ```io:format``` аналогично тому, что было описано выше. Обратите внимание, что ```~-15w``` говорит, чтобы напечатать "термин" с длиной поля (шириной) 15 и слева оправдать его. (см. страницу руководства io (3)) в STDLIB.

Теперь ```format_temps(Rest)``` вызывается с остальной частью списка в качестве аргумента. Этот способ выполнения вещей похож на циклические конструкции в других языках. (Да, это рекурсия, но пусть это вас не беспокоит.) Таким образом, снова вызывается та же функция ```format_temps```, на этот раз ```City``` получает значение ```{cape_town, {f, 70}}``` и повторяется та же процедура, что и раньше. Это делается до тех пор, пока список не станет пустым, то есть ```[]```, что приводит к совпадению первого предложения format_temps ```([])```. Это просто возвращает (приводит к) атому  ```ok```, так что программа заканчивается.

# 4. Ссылки и источники

* [Официальный сайт](https://www.erlang.org/)
* [Официальный репозиторий](https://github.com/erlang/otp)
* [Официальный Quick Start гайд](http://erlang.org/faq/getting_started.html)
* [Официальный Reference Manual](http://erlang.org/doc/reference_manual/introduction.html)
* [Пользовательский Intro гайд](https://ru.hexlet.io/courses/erlang_101/lessons/practical_erlang_intro_and_types/theory_unit)